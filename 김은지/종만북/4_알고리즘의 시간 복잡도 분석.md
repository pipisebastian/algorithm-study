알고리즘 : 어떤 작업이 주어졌을 때 컴퓨터가 이 작업을 해결하는 방법

- 한 문제를 해결하는 데 여러 개의 알고리즘이 있을 수 있다면 그중 어떤 알고리즘을 만드는 법을 배워야 할까?
  -> 알고리즘을 평가하는 두 가지 큰 기주 `시간`, `공간`
  - 적은 시간 -> 더 빠르게 동작
  - 적은 공간 -> 더 적은 용량의 메모리 사용

### 4.1 도입

- 빠른 알고리즘을 만드려면? -> 가장 먼저 속도를 어떻게 측정할지 정해야 한다
- 속도를 비교하는 가장 직관적인 방법은 각각을 프로그램으로 구현한 뒤 같은 입력에 대해 두 프로그램의 수행 시간을 측정하는 것이다.
  => BUT!
  - 프로그램의 실행 시간은 알고리즘의 속도를 일반적으로 이야기하는 기준이 되기에는 부적합 - 사용한 프로그래밍 언어, 하드웨어, 운영체제, 컴파일러 등 수많은 요소에 의해 바뀔 수 있기 때문
  - 프로그램의 실제 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못함 - 입력의 크기나 특성에 따라 수행 시간이 달라질 수 있음
- 그럼 알고리즘의 수행 시간을 어떤 기준으로 측정해야 할까?
  - 입력의 크기가 작을 때는 반복 외의 다른 부분들이 갖는 비중이 클 수 있지만, 입력의 크기가 커지면 커질수록 **반복문**이 알고리즘의 수행 시간을 지배하게 됨
    => 대개 우리는 알고리즘의 수행 시간을 반복문이 수행되는 횟수(입력 크기에 대한 함수)로 측정

### 4.2 선형 시간 알고리즘

- 선형 시간에 실행되는 알고리즘은 대개 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많음 (주어진 입력을 최소한 한 번씩 쳐다보기라도 하려면 선형 시간이 걸릴 수 밖에 없음)
- N

### 4.3 선형 이하 시간 알고리즘

- 입력으로 주어진 자료에 대해 우리가 미리 알고 있는 지식을 활용할 수 있다면 선형 시간보다 빠르게 동작할 수 있음
- lgN

### 4.4 지수 시간 알고리즘

- 다항 시간 알고리즘 (N, N^2, N^3, ...) 보다 더욱 오랜 시간이 걸리는 알고리즘인 지수 시간 알고리즘
- 2^N

### 4.5 시간 복잡도

- 시간 복잡도 : 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것 \*기본적인 연산 : 더 작게 쪼갤 수 없는 최소 크기의 연산 (ex. 두 보호 있는 32비트 정수 사칙연산, 두 실수형 변수의 대소 비교, 한 변수에 다른 변수 대입하기)
- 시간 복잡도가 높다 - 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미 (시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아님 -> 입력의 크기가 매우 작을 경우 시간 복잡도는 큰 의미를 갖지 못할 수도 있음)
- 입력의 크기 뿐 아니라 입력이 어떤 형태로 구성되어 있는 지도 수행 시간에 영향을 미침 -> 최선/최악/평균적인 경우에 대한 수행 시간을 각각 따로 계산
- 대개 최악의 수행 시간 혹은 수행 시간의 기대치를 사용하는데 여러 알고리즘에서 두 기준이 거의 같기 때문에 따로 구분되지 않고 쓰임

- O 표기법
  - 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법
  - 가장 깊이 중첩된 반복문의 수행 횟수를 계산하는 것
  - 수행 시간의 상한을 나타낸다는 사실을 통해 알고리즘의 최악의 수행 시간을 알아냈다고 착각하는 일이 흔히 있는데, 각 경우의 수행 시간을 간단히 나타내는 표기법일 뿐, 특별히 최악의 수행 시간과 관련이 있는 것은 아님 (퀵 정렬의 최악의 수행 시간은 N^2이지만 편균 수행 시간은 NlgN)
  - 알고리즘의 시간 복잡도를 항상 반복문의 개수를 세는 것으로만 결정하지는 않음 - 조건에 따라 그보다 더 정확한 시간 복잡도 계산 가능
    - ex. 시간 복잡도의 분할 상환 분석
      - 작업에 걸리는 시간은 모두 다르지만 전체 작업에 걸리는 시간이 일정한 경우 적용 가능
      - 각 작업에 걸리는 평균 시간은 전체 시간을 작업의 개수로 나눈 것과 같음

### 4.6 수행 시간 어림짐작하기

- 프로그래밍 대회의 시간 제한은 알고리즘의 시간 복잡도가 아니라 프로그램의 수행 시간을 기준으로 함 -> 어떤 알고리즘이 이 문제를 해결할 수 있을지 알기 위해서는 프로그램을 작성하기 전에 입력의 최대 크기와 알고리즘의 시간 복잡도를 보고 수행 시간을 어림짐작할 수 있어야 함
- 프로그램의 동작 속도에 영향을 끼치는 요소는 입력의 크기와 시간 복잡도를 제외하고도 엄청나게 많지만, 시간 복잡도가 프로그램의 수행 시간에 가장 큰 영향을 미치는 요소이기 때문에 많은 경우 시간 복잡도와 입력 크기만 알고 있더라도 어떤 알고리즘이 시간 안에 동작할지 대략적으로 짐작 가능
- **입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억(10^8)을 넘어가면 시간 제한을 초과할 가능성이 있다.**
- 입력의 크기 외의 요소들이 프로그램 수행 속도를 열 배 정도는 쉽게 바꿔 놓을 수 있기 때문에 충분한 여유를 두는 것이 좋다.
- 시간 복잡도 외에 고려해야 하는 요소
  - 시간 복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우
  - 반복문의 내부가 복잡한 경우
    - 반복문 내부가 길거나
    - 시간이 많이 걸리는 연산(실수 연산, 파일 입출력)을 많이 사용할 경우
  - 메모리 사용 패턴이 복잡한 경우
  - 언어와 컴파일러의 차이
  - 구형 컴퓨터를 사용하는 경우

### 4.7 계산 복잡도 클래스: P, NP, NP-완비

- 계산 복잡도 클래스 : 같은 성질을 갖는 문제들을 모아놓은 집합
- P 문제 : 다항 시간 알고리즘이 존재하는 문제들의 집함
- NP 문제 : 답이 주어졌을 때 이것이 정답인지를 다향 시간 내에 확인할 수 있는 문제
- 모든 P 문제들은 모두 NP 문제에도 포함 된다.

### 4.8 더 읽을거리

- 마스터 정리 - 재귀적인 알고리즘의 시간 복잡도를 계산하는 쉬운 방법
