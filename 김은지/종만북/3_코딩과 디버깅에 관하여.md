### 3.1 도입: 코딩의 중요성을 간과하지 말라

- 읽기 쉬운 코드를 작성하는 것

### 3.2 좋은 코드를 짜기 위한 원칙

- 간결한 코드를 작성하기
  - 코드가 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워짐
  - 일반적인 프로그램에서 권장할 수 없지만, 프로그래밍 대회에서 작성하는 코드는 구조가 매우 단순하고, 각 변수를 읽고 쓰는 부분이 어디인지가 비교적 명확하기 때문에
    => 전역 변수의 광범위한 사용도 괜춘
  - C/C++의 경우 매크로 사용을 통한 간결한 코드 작성도 유용
- 적극적으로 코드 재사용하기
  - 모듈화
  - 같은 코드 세 번 이상이면 함수로 분리해 재사용하는 등 기본 원칙 만들면 좋음
  - 이상적인 세계에서는 한 함수가 두 가지 이상의 일을 해서는 안 된다고 하지만 이정도로 엄격하게 원칙을 따르진 않아도 됨 (시간 제한과 재사용 한계등의 이유)
- 표준 라이브러리 공부하기
  - 검증된 가져와 사용할 수 있는 표준 라이브러리는 직접 구현하기 보다 가져와 사용하는 게 좋음
- 항상 같은 형태로 프로그램 작성하기
  - 자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 이것만을 꾸준히 사용할 필요가 있음
    - 코드를 검증한다는 것은 그렇게 쉬운일이 아니기 때문에 도구가 아니라 문제에 집중할 수 있도록!
- 일관적이고 명료한 명명법 사용하기
- 모든 자료를 정규화해서 저장하기
  - 표현하는 방법을 한 가지로 정의해 두지 않으면 해당 데이터를 다루는 함수들을 작성하기 어려움
  - 정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어져야 함. 이상적으로는 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나, 외부에서 자료를 입력받자마자 정규화를 수행하는 것이 좋음
- 코드와 데이터를 분리하기
  - 코드의 논리와 상관 없는 데이터는 가능한 한 분리하는 것이 좋음

### 3.3 자주 하는 실수

- 산술 오버플로
- 배열 범위 밖 원소에 접근
  - 오류도 나지 않으면서 틀린 답만 내놓는 경우도 더러 있음
- 일관되지 않은 범위 표현 방식 사용하기
- Off-by-one 오류
  - 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 모두 가리킴
- 컴파일러가 잡아주지 못하는 상수 오타
- 스택 오버플로
  - 대개 재귀 호출의 깊이가 너무 깊어져서 옴
- 다차원 배열 인덱스 순서 바꿔 쓰기
- 잘못된 비교 함수 작성
- 최소, 최대 예외 잘못 다루기
  - 가장 작은 입력과 가장 큰 입력에 대해 제대로 동작할지를 생각해보면 오류를 잡을 수 있는 경우가 꽤 있음
- 연산자 우선순위 잘못 쓰기
- 너무 느린 입출력 방식 선택
- 변수 초기화 문제
  - 이전 입력에서 사용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 것

### 3.4 디버깅과 테스팅

**디버깅에 관하여**

- 프로그래밍 대회에서는 디버거 없이 프로그램 버그를 찾아내는 게 도움이 될 수 있음
  - 작은 입력에 대해 제대로 실행되나 확인하기
  - 단정문 쓰기
    - 단정문 : 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문
  - 프로그램의 계산 중간 결과 출력하기
- 디버거 사용해도 좋은 경우
  - 위의 과정을 거쳐 어디에서 문제가 일어나는지까지는 얼추 알았지만, 무엇이 틀렸는 지 모르겠는 경우
  - 프로그램이 런타임 오류를 내고 종료하는 경우

**테스트에 관하여**

- 가능한 많은 예제 입력 만들어 테스트하는 것이 좋음
- 스캐폴딩 : (in 프로그래밍) 다른 코드를 개발할 때 뼈대를 잡기 위해 임시로 사용하는 코드
  - 코드의 정당성을 확인하거나 반례를 찾는데 특히 유용함
  - 임의의 작은 입력을 자동으로 생성해 프로그램을 돌려 보고, 그 답안을 검증하는 프로그램을 짜면 큰 도움이 됨

### 3.5 변수 범위의 이해

- 산술 오버플로
  - : 어떤 식의 계산 값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우
  - 발생 경우
    - 너무 큰 결과
    - 너무 큰 중간 값 - 중간 과정에서 큰 값을 일시적으로 계산해야 하는 경우
    - 너무 큰 '무한대' 값
  - 막는 방법
    - 더 큰 자료형 쓰기
    - 오버플로가 나지 않도록 연산 순서 바꾸기
- 자료형의 프로모션
  - : 피연산자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러들이 같은 자료형으로 변환해서 계산 하는 것
  - 대부분의 경우 신경 쓸 필요 없지만 가끔 알기 어려운 버그를 만듦
  - 발생 경우
    - 대개 부호 있는 정수와 부호 없는 정수형이 섞였을 때 일어남

### 3.6 실수 자료형의 이해

- 정수들은 컴퓨터가 정확하게 표현할 수 있는 반면, 실수에서는 이야기가 다름
- 컴퓨터의 메모리는 유한하고, 이 모든 값들을 모두 정확하게 담을 수는 없으니 어쩔 수 없이 적절히 비슷한 값을 사용하는 것으로 만족해야 함
  -> 컴퓨터의 모든 실수 변수는 정확도가 제한된 근사 값을 저장함
- IEEE 754 표준
  - 이진수로 실수를 표기
  - 부동 소수점 표기법
    : 소수점을 움직이는 실수 표기법 (<-> 고정 소수점 실수 표기법)
  - 무한대, 비정규 수, NaN 등의 특수한 값 존재

### 3.7 더 읽을거리

- ⌜클린 코드⌟
